// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSmsg.proto

#ifndef PROTOBUF_CSmsg_2eproto__INCLUDED
#define PROTOBUF_CSmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSmsg_2eproto();
void protobuf_AssignDesc_CSmsg_2eproto();
void protobuf_ShutdownFile_CSmsg_2eproto();

class CSLoginReq;
class CSLoginRsp;
class CSRegisterReq;
class CSRegisterRsp;
class CSRegisterLoginReqParam;
class CSRegisterLoginRspParam;
class CSRegisterLoginReq;
class CSRegisterLoginRsp;
class CSMsgBody;
class CSMsgHead;
class CSMsg;

enum CSRegisterLoginCmd {
  CSRegisterLoginCmd_Register = 1,
  CSRegisterLoginCmd_Login = 2
};
bool CSRegisterLoginCmd_IsValid(int value);
const CSRegisterLoginCmd CSRegisterLoginCmd_MIN = CSRegisterLoginCmd_Register;
const CSRegisterLoginCmd CSRegisterLoginCmd_MAX = CSRegisterLoginCmd_Login;
const int CSRegisterLoginCmd_ARRAYSIZE = CSRegisterLoginCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* CSRegisterLoginCmd_descriptor();
inline const ::std::string& CSRegisterLoginCmd_Name(CSRegisterLoginCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    CSRegisterLoginCmd_descriptor(), value);
}
inline bool CSRegisterLoginCmd_Parse(
    const ::std::string& name, CSRegisterLoginCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CSRegisterLoginCmd>(
    CSRegisterLoginCmd_descriptor(), name, value);
}
enum CSMsgID {
  CS_MSGID_MIN = 0,
  CS_MSGID_RegisterLogin = 1,
  CS_MSGID_MAX = 2
};
bool CSMsgID_IsValid(int value);
const CSMsgID CSMsgID_MIN = CS_MSGID_MIN;
const CSMsgID CSMsgID_MAX = CS_MSGID_MAX;
const int CSMsgID_ARRAYSIZE = CSMsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* CSMsgID_descriptor();
inline const ::std::string& CSMsgID_Name(CSMsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    CSMsgID_descriptor(), value);
}
inline bool CSMsgID_Parse(
    const ::std::string& name, CSMsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CSMsgID>(
    CSMsgID_descriptor(), name, value);
}
// ===================================================================

class CSLoginReq : public ::google::protobuf::Message {
 public:
  CSLoginReq();
  virtual ~CSLoginReq();

  CSLoginReq(const CSLoginReq& from);

  inline CSLoginReq& operator=(const CSLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSLoginReq& default_instance();

  void Swap(CSLoginReq* other);

  // implements Message ----------------------------------------------

  CSLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSLoginReq& from);
  void MergeFrom(const CSLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:CSLoginReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class CSLoginRsp : public ::google::protobuf::Message {
 public:
  CSLoginRsp();
  virtual ~CSLoginRsp();

  CSLoginRsp(const CSLoginRsp& from);

  inline CSLoginRsp& operator=(const CSLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSLoginRsp& default_instance();

  void Swap(CSLoginRsp* other);

  // implements Message ----------------------------------------------

  CSLoginRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSLoginRsp& from);
  void MergeFrom(const CSLoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSLoginRsp)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSLoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterReq : public ::google::protobuf::Message {
 public:
  CSRegisterReq();
  virtual ~CSRegisterReq();

  CSRegisterReq(const CSRegisterReq& from);

  inline CSRegisterReq& operator=(const CSRegisterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterReq& default_instance();

  void Swap(CSRegisterReq* other);

  // implements Message ----------------------------------------------

  CSRegisterReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterReq& from);
  void MergeFrom(const CSRegisterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSRegisterReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;
  ::std::string* name_;
  ::google::protobuf::uint32 sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterRsp : public ::google::protobuf::Message {
 public:
  CSRegisterRsp();
  virtual ~CSRegisterRsp();

  CSRegisterRsp(const CSRegisterRsp& from);

  inline CSRegisterRsp& operator=(const CSRegisterRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterRsp& default_instance();

  void Swap(CSRegisterRsp* other);

  // implements Message ----------------------------------------------

  CSRegisterRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterRsp& from);
  void MergeFrom(const CSRegisterRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSRegisterRsp)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterLoginReqParam : public ::google::protobuf::Message {
 public:
  CSRegisterLoginReqParam();
  virtual ~CSRegisterLoginReqParam();

  CSRegisterLoginReqParam(const CSRegisterLoginReqParam& from);

  inline CSRegisterLoginReqParam& operator=(const CSRegisterLoginReqParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterLoginReqParam& default_instance();

  void Swap(CSRegisterLoginReqParam* other);

  // implements Message ----------------------------------------------

  CSRegisterLoginReqParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterLoginReqParam& from);
  void MergeFrom(const CSRegisterLoginReqParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSLoginReq LoginReq = 1;
  inline bool has_loginreq() const;
  inline void clear_loginreq();
  static const int kLoginReqFieldNumber = 1;
  inline const ::CSLoginReq& loginreq() const;
  inline ::CSLoginReq* mutable_loginreq();
  inline ::CSLoginReq* release_loginreq();
  inline void set_allocated_loginreq(::CSLoginReq* loginreq);

  // optional .CSRegisterReq RegisterReq = 2;
  inline bool has_registerreq() const;
  inline void clear_registerreq();
  static const int kRegisterReqFieldNumber = 2;
  inline const ::CSRegisterReq& registerreq() const;
  inline ::CSRegisterReq* mutable_registerreq();
  inline ::CSRegisterReq* release_registerreq();
  inline void set_allocated_registerreq(::CSRegisterReq* registerreq);

  // @@protoc_insertion_point(class_scope:CSRegisterLoginReqParam)
 private:
  inline void set_has_loginreq();
  inline void clear_has_loginreq();
  inline void set_has_registerreq();
  inline void clear_has_registerreq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSLoginReq* loginreq_;
  ::CSRegisterReq* registerreq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterLoginReqParam* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterLoginRspParam : public ::google::protobuf::Message {
 public:
  CSRegisterLoginRspParam();
  virtual ~CSRegisterLoginRspParam();

  CSRegisterLoginRspParam(const CSRegisterLoginRspParam& from);

  inline CSRegisterLoginRspParam& operator=(const CSRegisterLoginRspParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterLoginRspParam& default_instance();

  void Swap(CSRegisterLoginRspParam* other);

  // implements Message ----------------------------------------------

  CSRegisterLoginRspParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterLoginRspParam& from);
  void MergeFrom(const CSRegisterLoginRspParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSLoginRsp LoginRsp = 1;
  inline bool has_loginrsp() const;
  inline void clear_loginrsp();
  static const int kLoginRspFieldNumber = 1;
  inline const ::CSLoginRsp& loginrsp() const;
  inline ::CSLoginRsp* mutable_loginrsp();
  inline ::CSLoginRsp* release_loginrsp();
  inline void set_allocated_loginrsp(::CSLoginRsp* loginrsp);

  // optional .CSRegisterRsp RegisterRsp = 2;
  inline bool has_registerrsp() const;
  inline void clear_registerrsp();
  static const int kRegisterRspFieldNumber = 2;
  inline const ::CSRegisterRsp& registerrsp() const;
  inline ::CSRegisterRsp* mutable_registerrsp();
  inline ::CSRegisterRsp* release_registerrsp();
  inline void set_allocated_registerrsp(::CSRegisterRsp* registerrsp);

  // @@protoc_insertion_point(class_scope:CSRegisterLoginRspParam)
 private:
  inline void set_has_loginrsp();
  inline void clear_has_loginrsp();
  inline void set_has_registerrsp();
  inline void clear_has_registerrsp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSLoginRsp* loginrsp_;
  ::CSRegisterRsp* registerrsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterLoginRspParam* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterLoginReq : public ::google::protobuf::Message {
 public:
  CSRegisterLoginReq();
  virtual ~CSRegisterLoginReq();

  CSRegisterLoginReq(const CSRegisterLoginReq& from);

  inline CSRegisterLoginReq& operator=(const CSRegisterLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterLoginReq& default_instance();

  void Swap(CSRegisterLoginReq* other);

  // implements Message ----------------------------------------------

  CSRegisterLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterLoginReq& from);
  void MergeFrom(const CSRegisterLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CSRegisterLoginCmd cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::CSRegisterLoginCmd cmd() const;
  inline void set_cmd(::CSRegisterLoginCmd value);

  // optional .CSRegisterLoginReqParam reqParam = 2;
  inline bool has_reqparam() const;
  inline void clear_reqparam();
  static const int kReqParamFieldNumber = 2;
  inline const ::CSRegisterLoginReqParam& reqparam() const;
  inline ::CSRegisterLoginReqParam* mutable_reqparam();
  inline ::CSRegisterLoginReqParam* release_reqparam();
  inline void set_allocated_reqparam(::CSRegisterLoginReqParam* reqparam);

  // @@protoc_insertion_point(class_scope:CSRegisterLoginReq)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_reqparam();
  inline void clear_has_reqparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSRegisterLoginReqParam* reqparam_;
  int cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterLoginRsp : public ::google::protobuf::Message {
 public:
  CSRegisterLoginRsp();
  virtual ~CSRegisterLoginRsp();

  CSRegisterLoginRsp(const CSRegisterLoginRsp& from);

  inline CSRegisterLoginRsp& operator=(const CSRegisterLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterLoginRsp& default_instance();

  void Swap(CSRegisterLoginRsp* other);

  // implements Message ----------------------------------------------

  CSRegisterLoginRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterLoginRsp& from);
  void MergeFrom(const CSRegisterLoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required .CSRegisterLoginCmd cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::CSRegisterLoginCmd cmd() const;
  inline void set_cmd(::CSRegisterLoginCmd value);

  // optional .CSRegisterLoginRspParam rspParam = 3;
  inline bool has_rspparam() const;
  inline void clear_rspparam();
  static const int kRspParamFieldNumber = 3;
  inline const ::CSRegisterLoginRspParam& rspparam() const;
  inline ::CSRegisterLoginRspParam* mutable_rspparam();
  inline ::CSRegisterLoginRspParam* release_rspparam();
  inline void set_allocated_rspparam(::CSRegisterLoginRspParam* rspparam);

  // @@protoc_insertion_point(class_scope:CSRegisterLoginRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_rspparam();
  inline void clear_has_rspparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  int cmd_;
  ::CSRegisterLoginRspParam* rspparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterLoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSMsgBody : public ::google::protobuf::Message {
 public:
  CSMsgBody();
  virtual ~CSMsgBody();

  CSMsgBody(const CSMsgBody& from);

  inline CSMsgBody& operator=(const CSMsgBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsgBody& default_instance();

  void Swap(CSMsgBody* other);

  // implements Message ----------------------------------------------

  CSMsgBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsgBody& from);
  void MergeFrom(const CSMsgBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSRegisterLoginReq RegisterLoginReq = 1;
  inline bool has_registerloginreq() const;
  inline void clear_registerloginreq();
  static const int kRegisterLoginReqFieldNumber = 1;
  inline const ::CSRegisterLoginReq& registerloginreq() const;
  inline ::CSRegisterLoginReq* mutable_registerloginreq();
  inline ::CSRegisterLoginReq* release_registerloginreq();
  inline void set_allocated_registerloginreq(::CSRegisterLoginReq* registerloginreq);

  // optional .CSRegisterLoginRsp RegisterLoginRsp = 2;
  inline bool has_registerloginrsp() const;
  inline void clear_registerloginrsp();
  static const int kRegisterLoginRspFieldNumber = 2;
  inline const ::CSRegisterLoginRsp& registerloginrsp() const;
  inline ::CSRegisterLoginRsp* mutable_registerloginrsp();
  inline ::CSRegisterLoginRsp* release_registerloginrsp();
  inline void set_allocated_registerloginrsp(::CSRegisterLoginRsp* registerloginrsp);

  // @@protoc_insertion_point(class_scope:CSMsgBody)
 private:
  inline void set_has_registerloginreq();
  inline void clear_has_registerloginreq();
  inline void set_has_registerloginrsp();
  inline void clear_has_registerloginrsp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSRegisterLoginReq* registerloginreq_;
  ::CSRegisterLoginRsp* registerloginrsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSMsgBody* default_instance_;
};
// -------------------------------------------------------------------

class CSMsgHead : public ::google::protobuf::Message {
 public:
  CSMsgHead();
  virtual ~CSMsgHead();

  CSMsgHead(const CSMsgHead& from);

  inline CSMsgHead& operator=(const CSMsgHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsgHead& default_instance();

  void Swap(CSMsgHead* other);

  // implements Message ----------------------------------------------

  CSMsgHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsgHead& from);
  void MergeFrom(const CSMsgHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required .CSMsgID msgID = 2;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 2;
  inline ::CSMsgID msgid() const;
  inline void set_msgid(::CSMsgID value);

  // @@protoc_insertion_point(class_scope:CSMsgHead)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  int msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSMsgHead* default_instance_;
};
// -------------------------------------------------------------------

class CSMsg : public ::google::protobuf::Message {
 public:
  CSMsg();
  virtual ~CSMsg();

  CSMsg(const CSMsg& from);

  inline CSMsg& operator=(const CSMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsg& default_instance();

  void Swap(CSMsg* other);

  // implements Message ----------------------------------------------

  CSMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsg& from);
  void MergeFrom(const CSMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CSMsgHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::CSMsgHead& head() const;
  inline ::CSMsgHead* mutable_head();
  inline ::CSMsgHead* release_head();
  inline void set_allocated_head(::CSMsgHead* head);

  // required .CSMsgBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::CSMsgBody& body() const;
  inline ::CSMsgBody* mutable_body();
  inline ::CSMsgBody* release_body();
  inline void set_allocated_body(::CSMsgBody* body);

  // @@protoc_insertion_point(class_scope:CSMsg)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSMsgHead* head_;
  ::CSMsgBody* body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// CSLoginReq

// optional string account = 1;
inline bool CSLoginReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CSLoginReq::account() const {
  return *account_;
}
inline void CSLoginReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CSLoginReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CSLoginReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CSLoginReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool CSLoginReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLoginReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLoginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLoginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CSLoginReq::password() const {
  return *password_;
}
inline void CSLoginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSLoginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSLoginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CSLoginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSLoginRsp

// optional uint32 type = 1;
inline bool CSLoginRsp::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginRsp::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginRsp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSLoginRsp::type() const {
  return type_;
}
inline void CSLoginRsp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CSRegisterReq

// optional string account = 1;
inline bool CSRegisterReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CSRegisterReq::account() const {
  return *account_;
}
inline void CSRegisterReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CSRegisterReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CSRegisterReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRegisterReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CSRegisterReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRegisterReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool CSRegisterReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CSRegisterReq::password() const {
  return *password_;
}
inline void CSRegisterReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSRegisterReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSRegisterReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRegisterReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CSRegisterReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRegisterReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool CSRegisterReq::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRegisterReq::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRegisterReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRegisterReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSRegisterReq::name() const {
  return *name_;
}
inline void CSRegisterReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSRegisterReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSRegisterReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRegisterReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSRegisterReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRegisterReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sex = 4;
inline bool CSRegisterReq::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSRegisterReq::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSRegisterReq::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSRegisterReq::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 CSRegisterReq::sex() const {
  return sex_;
}
inline void CSRegisterReq::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// CSRegisterRsp

// optional uint32 type = 1;
inline bool CSRegisterRsp::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterRsp::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterRsp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSRegisterRsp::type() const {
  return type_;
}
inline void CSRegisterRsp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CSRegisterLoginReqParam

// optional .CSLoginReq LoginReq = 1;
inline bool CSRegisterLoginReqParam::has_loginreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterLoginReqParam::set_has_loginreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterLoginReqParam::clear_has_loginreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterLoginReqParam::clear_loginreq() {
  if (loginreq_ != NULL) loginreq_->::CSLoginReq::Clear();
  clear_has_loginreq();
}
inline const ::CSLoginReq& CSRegisterLoginReqParam::loginreq() const {
  return loginreq_ != NULL ? *loginreq_ : *default_instance_->loginreq_;
}
inline ::CSLoginReq* CSRegisterLoginReqParam::mutable_loginreq() {
  set_has_loginreq();
  if (loginreq_ == NULL) loginreq_ = new ::CSLoginReq;
  return loginreq_;
}
inline ::CSLoginReq* CSRegisterLoginReqParam::release_loginreq() {
  clear_has_loginreq();
  ::CSLoginReq* temp = loginreq_;
  loginreq_ = NULL;
  return temp;
}
inline void CSRegisterLoginReqParam::set_allocated_loginreq(::CSLoginReq* loginreq) {
  delete loginreq_;
  loginreq_ = loginreq;
  if (loginreq) {
    set_has_loginreq();
  } else {
    clear_has_loginreq();
  }
}

// optional .CSRegisterReq RegisterReq = 2;
inline bool CSRegisterLoginReqParam::has_registerreq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterLoginReqParam::set_has_registerreq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterLoginReqParam::clear_has_registerreq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterLoginReqParam::clear_registerreq() {
  if (registerreq_ != NULL) registerreq_->::CSRegisterReq::Clear();
  clear_has_registerreq();
}
inline const ::CSRegisterReq& CSRegisterLoginReqParam::registerreq() const {
  return registerreq_ != NULL ? *registerreq_ : *default_instance_->registerreq_;
}
inline ::CSRegisterReq* CSRegisterLoginReqParam::mutable_registerreq() {
  set_has_registerreq();
  if (registerreq_ == NULL) registerreq_ = new ::CSRegisterReq;
  return registerreq_;
}
inline ::CSRegisterReq* CSRegisterLoginReqParam::release_registerreq() {
  clear_has_registerreq();
  ::CSRegisterReq* temp = registerreq_;
  registerreq_ = NULL;
  return temp;
}
inline void CSRegisterLoginReqParam::set_allocated_registerreq(::CSRegisterReq* registerreq) {
  delete registerreq_;
  registerreq_ = registerreq;
  if (registerreq) {
    set_has_registerreq();
  } else {
    clear_has_registerreq();
  }
}

// -------------------------------------------------------------------

// CSRegisterLoginRspParam

// optional .CSLoginRsp LoginRsp = 1;
inline bool CSRegisterLoginRspParam::has_loginrsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterLoginRspParam::set_has_loginrsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterLoginRspParam::clear_has_loginrsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterLoginRspParam::clear_loginrsp() {
  if (loginrsp_ != NULL) loginrsp_->::CSLoginRsp::Clear();
  clear_has_loginrsp();
}
inline const ::CSLoginRsp& CSRegisterLoginRspParam::loginrsp() const {
  return loginrsp_ != NULL ? *loginrsp_ : *default_instance_->loginrsp_;
}
inline ::CSLoginRsp* CSRegisterLoginRspParam::mutable_loginrsp() {
  set_has_loginrsp();
  if (loginrsp_ == NULL) loginrsp_ = new ::CSLoginRsp;
  return loginrsp_;
}
inline ::CSLoginRsp* CSRegisterLoginRspParam::release_loginrsp() {
  clear_has_loginrsp();
  ::CSLoginRsp* temp = loginrsp_;
  loginrsp_ = NULL;
  return temp;
}
inline void CSRegisterLoginRspParam::set_allocated_loginrsp(::CSLoginRsp* loginrsp) {
  delete loginrsp_;
  loginrsp_ = loginrsp;
  if (loginrsp) {
    set_has_loginrsp();
  } else {
    clear_has_loginrsp();
  }
}

// optional .CSRegisterRsp RegisterRsp = 2;
inline bool CSRegisterLoginRspParam::has_registerrsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterLoginRspParam::set_has_registerrsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterLoginRspParam::clear_has_registerrsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterLoginRspParam::clear_registerrsp() {
  if (registerrsp_ != NULL) registerrsp_->::CSRegisterRsp::Clear();
  clear_has_registerrsp();
}
inline const ::CSRegisterRsp& CSRegisterLoginRspParam::registerrsp() const {
  return registerrsp_ != NULL ? *registerrsp_ : *default_instance_->registerrsp_;
}
inline ::CSRegisterRsp* CSRegisterLoginRspParam::mutable_registerrsp() {
  set_has_registerrsp();
  if (registerrsp_ == NULL) registerrsp_ = new ::CSRegisterRsp;
  return registerrsp_;
}
inline ::CSRegisterRsp* CSRegisterLoginRspParam::release_registerrsp() {
  clear_has_registerrsp();
  ::CSRegisterRsp* temp = registerrsp_;
  registerrsp_ = NULL;
  return temp;
}
inline void CSRegisterLoginRspParam::set_allocated_registerrsp(::CSRegisterRsp* registerrsp) {
  delete registerrsp_;
  registerrsp_ = registerrsp;
  if (registerrsp) {
    set_has_registerrsp();
  } else {
    clear_has_registerrsp();
  }
}

// -------------------------------------------------------------------

// CSRegisterLoginReq

// required .CSRegisterLoginCmd cmd = 1;
inline bool CSRegisterLoginReq::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterLoginReq::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterLoginReq::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterLoginReq::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::CSRegisterLoginCmd CSRegisterLoginReq::cmd() const {
  return static_cast< ::CSRegisterLoginCmd >(cmd_);
}
inline void CSRegisterLoginReq::set_cmd(::CSRegisterLoginCmd value) {
  assert(::CSRegisterLoginCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .CSRegisterLoginReqParam reqParam = 2;
inline bool CSRegisterLoginReq::has_reqparam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterLoginReq::set_has_reqparam() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterLoginReq::clear_has_reqparam() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterLoginReq::clear_reqparam() {
  if (reqparam_ != NULL) reqparam_->::CSRegisterLoginReqParam::Clear();
  clear_has_reqparam();
}
inline const ::CSRegisterLoginReqParam& CSRegisterLoginReq::reqparam() const {
  return reqparam_ != NULL ? *reqparam_ : *default_instance_->reqparam_;
}
inline ::CSRegisterLoginReqParam* CSRegisterLoginReq::mutable_reqparam() {
  set_has_reqparam();
  if (reqparam_ == NULL) reqparam_ = new ::CSRegisterLoginReqParam;
  return reqparam_;
}
inline ::CSRegisterLoginReqParam* CSRegisterLoginReq::release_reqparam() {
  clear_has_reqparam();
  ::CSRegisterLoginReqParam* temp = reqparam_;
  reqparam_ = NULL;
  return temp;
}
inline void CSRegisterLoginReq::set_allocated_reqparam(::CSRegisterLoginReqParam* reqparam) {
  delete reqparam_;
  reqparam_ = reqparam;
  if (reqparam) {
    set_has_reqparam();
  } else {
    clear_has_reqparam();
  }
}

// -------------------------------------------------------------------

// CSRegisterLoginRsp

// optional int32 result = 1;
inline bool CSRegisterLoginRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterLoginRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterLoginRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterLoginRsp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CSRegisterLoginRsp::result() const {
  return result_;
}
inline void CSRegisterLoginRsp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required .CSRegisterLoginCmd cmd = 2;
inline bool CSRegisterLoginRsp::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterLoginRsp::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterLoginRsp::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterLoginRsp::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::CSRegisterLoginCmd CSRegisterLoginRsp::cmd() const {
  return static_cast< ::CSRegisterLoginCmd >(cmd_);
}
inline void CSRegisterLoginRsp::set_cmd(::CSRegisterLoginCmd value) {
  assert(::CSRegisterLoginCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .CSRegisterLoginRspParam rspParam = 3;
inline bool CSRegisterLoginRsp::has_rspparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRegisterLoginRsp::set_has_rspparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRegisterLoginRsp::clear_has_rspparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRegisterLoginRsp::clear_rspparam() {
  if (rspparam_ != NULL) rspparam_->::CSRegisterLoginRspParam::Clear();
  clear_has_rspparam();
}
inline const ::CSRegisterLoginRspParam& CSRegisterLoginRsp::rspparam() const {
  return rspparam_ != NULL ? *rspparam_ : *default_instance_->rspparam_;
}
inline ::CSRegisterLoginRspParam* CSRegisterLoginRsp::mutable_rspparam() {
  set_has_rspparam();
  if (rspparam_ == NULL) rspparam_ = new ::CSRegisterLoginRspParam;
  return rspparam_;
}
inline ::CSRegisterLoginRspParam* CSRegisterLoginRsp::release_rspparam() {
  clear_has_rspparam();
  ::CSRegisterLoginRspParam* temp = rspparam_;
  rspparam_ = NULL;
  return temp;
}
inline void CSRegisterLoginRsp::set_allocated_rspparam(::CSRegisterLoginRspParam* rspparam) {
  delete rspparam_;
  rspparam_ = rspparam;
  if (rspparam) {
    set_has_rspparam();
  } else {
    clear_has_rspparam();
  }
}

// -------------------------------------------------------------------

// CSMsgBody

// optional .CSRegisterLoginReq RegisterLoginReq = 1;
inline bool CSMsgBody::has_registerloginreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMsgBody::set_has_registerloginreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMsgBody::clear_has_registerloginreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMsgBody::clear_registerloginreq() {
  if (registerloginreq_ != NULL) registerloginreq_->::CSRegisterLoginReq::Clear();
  clear_has_registerloginreq();
}
inline const ::CSRegisterLoginReq& CSMsgBody::registerloginreq() const {
  return registerloginreq_ != NULL ? *registerloginreq_ : *default_instance_->registerloginreq_;
}
inline ::CSRegisterLoginReq* CSMsgBody::mutable_registerloginreq() {
  set_has_registerloginreq();
  if (registerloginreq_ == NULL) registerloginreq_ = new ::CSRegisterLoginReq;
  return registerloginreq_;
}
inline ::CSRegisterLoginReq* CSMsgBody::release_registerloginreq() {
  clear_has_registerloginreq();
  ::CSRegisterLoginReq* temp = registerloginreq_;
  registerloginreq_ = NULL;
  return temp;
}
inline void CSMsgBody::set_allocated_registerloginreq(::CSRegisterLoginReq* registerloginreq) {
  delete registerloginreq_;
  registerloginreq_ = registerloginreq;
  if (registerloginreq) {
    set_has_registerloginreq();
  } else {
    clear_has_registerloginreq();
  }
}

// optional .CSRegisterLoginRsp RegisterLoginRsp = 2;
inline bool CSMsgBody::has_registerloginrsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMsgBody::set_has_registerloginrsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMsgBody::clear_has_registerloginrsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMsgBody::clear_registerloginrsp() {
  if (registerloginrsp_ != NULL) registerloginrsp_->::CSRegisterLoginRsp::Clear();
  clear_has_registerloginrsp();
}
inline const ::CSRegisterLoginRsp& CSMsgBody::registerloginrsp() const {
  return registerloginrsp_ != NULL ? *registerloginrsp_ : *default_instance_->registerloginrsp_;
}
inline ::CSRegisterLoginRsp* CSMsgBody::mutable_registerloginrsp() {
  set_has_registerloginrsp();
  if (registerloginrsp_ == NULL) registerloginrsp_ = new ::CSRegisterLoginRsp;
  return registerloginrsp_;
}
inline ::CSRegisterLoginRsp* CSMsgBody::release_registerloginrsp() {
  clear_has_registerloginrsp();
  ::CSRegisterLoginRsp* temp = registerloginrsp_;
  registerloginrsp_ = NULL;
  return temp;
}
inline void CSMsgBody::set_allocated_registerloginrsp(::CSRegisterLoginRsp* registerloginrsp) {
  delete registerloginrsp_;
  registerloginrsp_ = registerloginrsp;
  if (registerloginrsp) {
    set_has_registerloginrsp();
  } else {
    clear_has_registerloginrsp();
  }
}

// -------------------------------------------------------------------

// CSMsgHead

// required uint64 uid = 1;
inline bool CSMsgHead::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMsgHead::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMsgHead::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMsgHead::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CSMsgHead::uid() const {
  return uid_;
}
inline void CSMsgHead::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required .CSMsgID msgID = 2;
inline bool CSMsgHead::has_msgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMsgHead::set_has_msgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMsgHead::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMsgHead::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline ::CSMsgID CSMsgHead::msgid() const {
  return static_cast< ::CSMsgID >(msgid_);
}
inline void CSMsgHead::set_msgid(::CSMsgID value) {
  assert(::CSMsgID_IsValid(value));
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// CSMsg

// required .CSMsgHead head = 1;
inline bool CSMsg::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMsg::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMsg::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMsg::clear_head() {
  if (head_ != NULL) head_->::CSMsgHead::Clear();
  clear_has_head();
}
inline const ::CSMsgHead& CSMsg::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::CSMsgHead* CSMsg::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::CSMsgHead;
  return head_;
}
inline ::CSMsgHead* CSMsg::release_head() {
  clear_has_head();
  ::CSMsgHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void CSMsg::set_allocated_head(::CSMsgHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// required .CSMsgBody body = 2;
inline bool CSMsg::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMsg::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMsg::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMsg::clear_body() {
  if (body_ != NULL) body_->::CSMsgBody::Clear();
  clear_has_body();
}
inline const ::CSMsgBody& CSMsg::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::CSMsgBody* CSMsg::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::CSMsgBody;
  return body_;
}
inline ::CSMsgBody* CSMsg::release_body() {
  clear_has_body();
  ::CSMsgBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline void CSMsg::set_allocated_body(::CSMsgBody* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CSRegisterLoginCmd>() {
  return ::CSRegisterLoginCmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CSMsgID>() {
  return ::CSMsgID_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSmsg_2eproto__INCLUDED
